import unittest
from pathlib import Path
import os
from fpga_globals import FPGA_MODELS
from fpga_primitives import MmcmBlockConfiguration, PllBlockConfiguration
from fpga_configurator import ClockingConfigurator
from utility import frequency_to_period_ns_precision, period_to_frequency_mhz_precision
import subprocess

# The tests of this module can only work with the vivado binary
# Insert your own path here if this generic one does not work
vivado_binary_path = str(Path.home()) + "/Xilinx/Vivado/2020.2/bin/vivado"
vivado_binary_available = Path(vivado_binary_path).is_file() and os.access(vivado_binary_path, os.X_OK)


def write_synthesis_and_clock_report_tcl_script(fpga_model_full_name: str, pin_names: list, signal_names: list,
                                                simulated_input_frequency: float = None,
                                                ) -> None:
    """
    Writes a tcl script that runs synthesis with given parameters and a file of the name "generated_test_template.v"
    :param signal_names:
    :param pin_names:
    :param fpga_model_full_name: Name of the used fpga model with Vivado naming conventions e.g. "xc7a35tftg256-3"
    :param simulated_input_frequency: Input frequency used for the fpga configuration
    :return: None
    """
    # Pin to signal assignment string:
    pin_assignment_str = "\n".join([f"set_property PACKAGE_PIN {pin_name} [get_ports {signal_name}]"
                                    for pin_name, signal_name in zip(pin_names, signal_names)]) + "\n"
    pin_ignore_str = "\n".join([f"set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets {name}_IBUF]"
                                for name in ["clkfbin", "clkin1"]]) + "\n"

    with open("tests/tcl/generated_test_script.tcl", "w") as file:
        file.write("set outputDir ./tests/tcl/output_dir\n"
                   f"set_part {fpga_model_full_name}\n"
                   "read_verilog ./tests/tcl/generated_test_template.v\n"
                   "synth_design -top clk\n"
                   "create_clock -name simulated_in_clk -period "
                   f"{round(frequency_to_period_ns_precision(simulated_input_frequency), 3)}"
                   " [get_ports clkin1]\n"
                   "opt_design\n"
                   "power_opt_design\n"
                   "place_design\n"
                   "phys_opt_design\n" +
                   pin_assignment_str +
                   pin_ignore_str +
                   "route_design\n"
                   "set_property IOSTANDARD LVCMOS18 "
                   "[get_ports -of_objects [get_iobanks -filter { BANK_TYPE !~  \"BT_MGT\" }]]\n"
                   # Generate a clock report under the "output_dir/generated_test_clock_report.rpt' path
                   # "set_property SEVERITY {Warning} [get_drc_checks UCIO-1]\n"
                   "report_clocks -file $outputDir/generated_test_clock_report.rpt\n"
                   "write_bitstream $outputDir/design.bit -force\n")


def write_integrity_test_tcl_script(fpga_model_full_name: str, primitive: str, properties: dict) -> None:
    """
    Writes a tcl script that calls the vivado clocking wizard and tries to assign arguments generated by THIS script
    :param fpga_model_full_name: Name of the used fpga model with Vivado naming conventions e.g. "xc7a35tftg256-3"
    :param primitive: PLL or MMCM
    :param properties: dictionary of all arguments that should be assigned via the clocking wizard
    :return: None
    """
    with open("tests/tcl/generated_test_script.tcl", "w") as file:
        file.write("set outputDir ./tests/tcl/output_dir\n"
                   "create_project -in_memory\n"
                   f"set_part {fpga_model_full_name}\n"
                   "create_ip -name clk_wiz -version 6.0 -vendor xilinx.com -module_name clk_wiz_instance\n"
                   "report_property [get_ips clk_wiz_instance]\n"
                   f"set_property CONFIG.PRIMITIVE {primitive} [get_ips clk_wiz_instance]\n")
        for key, value in properties.items():
            file.write(f"set_property CONFIG.{primitive}_{key} {value} [get_ips clk_wiz_instance]\n")


def write_test_verilog_template(template: str) -> None:
    """
    Writes a given string into a verilog file.
    This specific verilog file can then be automatically used by "write_integrity_test_tcl_script".
    :param template: Verilog representation of a clocking tile primitive configuration computed by THIS script
    :return:
    """
    with open(Path(__file__).parent.joinpath("tcl", "generated_test_template.v"), "w") as file:
        file.write(template)


def run_generated_tcl_script() -> str:
    """
    Runs the "tests/tcl/generated_test_script.tcl" tcl script via vivado, saves logs and returns vivados messages
    :return: The terminal output created by vivado
    """
    args = (vivado_binary_path, "-mode", "batch", "-source", "tests/tcl/generated_test_script.tcl", "-journal",
            "tests/tcl/output_dir/vivado.jou", "-log", "tests/tcl/output_dir/vivado.log")
    popen = subprocess.Popen(args, stdout=subprocess.PIPE)
    popen.wait()
    s = str(popen.stdout.read())
    popen.stdout.close()
    return s


def get_value_dict_from_clock_report() -> dict:
    """
    Extracts through simulation measured values from the clock report generated by
    "write_synthesis_and_clock_report_tcl_script"
    :return: dictionary that contains period, phase_shift, and duty_cycle of the measured clocks
    """
    with open("tests/tcl/output_dir/generated_test_clock_report.rpt") as file:
        s = "".join([line for line in file.readlines()])

    return {
        # Create a sub dictionary for each output frequency
        split[0]: {
            "frequency": period_to_frequency_mhz_precision(float(split[1])),
            "phase_shift": float(split[2][1:]) / float(split[1]) * 360,
            "duty_cycle": round((float(split[3][:-1]) - float(split[2][1:])) / float(split[1]), 3)}
        for split in
        [clock_line.split() for clock_line in
         s.split("Attributes  Sources")[1].split("====================================================")[0].split("\n")
         if clock_line != ""]
    }


@unittest.skipIf(not vivado_binary_available,
                 "Synthesis test was skipped since the necessary Vivado binary was not found." +
                 "Synthesis is (currently) possible only via Xilinx Vivado ML."
                 "\n Please insert your own Vivado binary path in \"test_synthesis.py\" in order to use this TestCase.")
class VivadoTest(unittest.TestCase):
    """
    Class handles all tests that use the vivado binary
    This includes simulation and synthesis of verilog files generated by THIS script
    """
    # Selected fpga models for tests
    artix_model = FPGA_MODELS[("artix-7", "#-3", "1.0V")]
    artix_model_vivado_name = "xc7a35tftg256-3"
    # Pins for the xc7a35tftg256-3 according to:
    # https://www.xilinx.com/support/packagefiles/a7packages/xc7a35tftg256pkg.txt
    artix_pin_names = ["G1", "G2", "G4", "H1", "H2", "H4", "J1", "K1", "K2", "K3", "L2", "L3", "L4", "G5", "H5", "J5",
                       "M1", "M2", "M4", "M5"]
    # Pins for the xc7k160tifbg484-2L according to:
    # https://www.xilinx.com/support/packagefiles/k7packages/xc7k160tfbg484pkg.txt
    kintex_model = FPGA_MODELS[("kintex-7", "#-2LI", "0.95V")]
    kintex_model_vivado_name = "xc7k160tifbg484-2L"
    kintex_pin_names = ["AA1", "AB1", "Y1", "W1", "W2", "U1", "T1", "R1", "P1", "P2", "R2", "AB2", "AA3", "V3", "AB3",
                        "N2", "N3", "M3"]
    # virtex test model not included because the Vivado Standard Edition does not provide support for virtex-7 models:
    # https://www.xilinx.com/products/design-tools/vivado/vivado-ml-buy.html#architecture

    # Selected input dictionaries
    # Tests with Vivado should be used sparingly because Vivado launches for each test script and takes lots of time.
    # One could argue that all tests should be done in one tcl script, which would lead to only one vivado launch,
    # but that would also lead to no isolation between tests

    # pll_test_dict and mmcm_test_dict work both for artix and kintex
    pll_test_dict = {
        "frequency_args": {"f_in_1": 237.5, "f_out_0": 133.7, "f_out_1": 69, "f_out_2": 500, "f_out_3": 180,
                           "f_out_4": 80, "f_out_5": 160, "delta_0": 0.003, "delta_1": 0.0005, "delta_2": 0.0009,
                           "delta_3": 0.012, "delta_4": 0.001, "delta_5": 0.044},
        "phase_shift_args": {"phase_shift_1": 240, "phase_shift_3": -320, "delta_1": 0.0022, "delta_3": 0.05},
        # "duty_cycle_args": {"duty_cycle_0": 0.125, "duty_cycle_1": 0.67, "delta_0": 0.07, "delta_1": 0.005},
        "other_args": {"bandwidth": "LOW", "startup_wait": False}}
    signal_names_pll_test = ["clkfbin", "clkfbout", "locked", "pwrdwn", "rst",
                             "clkin1", "clkout0", "clkout1", "clkout2", "clkout3", "clkout4", "clkout5"]
    mmcm_test_dict = {
        "frequency_args": {"f_in_1": 237.5, "f_out_0": 133.7, "f_out_1": 69, "f_out_2": 500, "f_out_3": 180,
                           "f_out_4": 80, "f_out_5": 160, "f_out_6": 370, "delta_0": 0.005, "delta_1": 0.016,
                           "delta_2": 0.02, "delta_3": 0.023, "delta_4": 0.05, "delta_5": 0.025,
                           "delta_6": 0.009},
        "phase_shift_args": {"phase_shift_1": 240, "phase_shift_3": -320, "delta_1": 0, "delta_3": 0.05},
        # "duty_cycle_args": {"duty_cycle_0": 0.125, "duty_cycle_1": 0.67, "delta_0": 0.095, "delta_1": 0.005},
        "other_args": {"bandwidth": "OPTIMIZED", "startup_wait": True}
    }
    signal_names_mmcm_test = ["clkfbin", "clkfbout", "locked", "pwrdwn", "rst", "clkin1",
                              "clkout0", "clkout1", "clkout2", "clkout3", "clkout4", "clkout5", "clkout6",
                              "clkboutb", "clkout0b", "clkout1b", "clkout2b", "clkout3b"]

    # It's nearly a copy of pll_test_dict
    # but some deltas had to change because the kintex' vco max is smaller than the artix'
    pll_kintex_test_dict = pll_test_dict.copy()
    for index, value in enumerate([0.015, 0.17, 0.04, 0.013]):
        pll_kintex_test_dict["frequency_args"][f"delta_{index + 1}"] = value
    pll_kintex_test_dict["frequency_args"]["delta_1"] = 0.015
    pll_kintex_test_dict["frequency_args"]["delta_2"] = 0.17
    pll_kintex_test_dict["frequency_args"]["delta_3"] = 0.04
    pll_kintex_test_dict["frequency_args"]["delta_4"] = 0.013
    pll_kintex_test_dict["phase_shift_args"]["delta_1"] = 0.005
    pll_kintex_test_dict["phase_shift_args"]["delta_3"] = 0.016

    # Also nearly a copy of mmcm_test_dict but with some changes on the delta values
    mmcm_kintex_test_dict = mmcm_test_dict.copy()
    for index, value in enumerate([0.03, 0.03, 0.11, 0.062, 0.025, 0.044, 0.1]):
        mmcm_kintex_test_dict["frequency_args"][f"delta_{index}"] = value
    mmcm_kintex_test_dict["phase_shift_args"]["delta_1"] = 0.005
    mmcm_kintex_test_dict["phase_shift_args"]["delta_3"] = 0.016

    # The pll_test_dict but without deltas
    pll_test_dict_without_deltas = pll_test_dict.copy()
    # The mmcm_test_dict but without detlef
    mmcm_test_dict_witout_deltas = mmcm_test_dict.copy()

    # Remove the deltas values from those dict copies
    for dic in [pll_test_dict_without_deltas, mmcm_test_dict_witout_deltas]:
        for key in ["frequency_args", "phase_shift_args"]:
            for sub_key in list(dic[key].keys()).copy():
                if "delta" in sub_key:
                    dic[key].pop(sub_key)

    artix_mmcm_cascade_test_dict_1 = {"frequency_args": {"f_in_1": 800, "f_out_0": 750, "f_out_1": 800, "f_out_4": 4.69,
                                                         "f_out_6": 19, "delta_0": 0.1, "delta_1": 0, "delta_4": 0.05,
                                                         "delta_6": 0.1, "f_out_4_cascade": True},
                                      "phase_shift_args": {},
                                      "other_args": {}}

    artix_mmcm_cascade_test_dict_2 = {"frequency_args": {"f_in_1": 800, "f_out_0": 750, "f_out_1": 800, "f_out_4": 4.69,
                                                         "delta_0": 0.1, "delta_1": 0, "delta_4": 0.05,
                                                         "f_out_4_cascade": True},
                                      "phase_shift_args": {},
                                      "other_args": {}}

    artix_mmcm_cascade_blank_test_dict = mmcm_test_dict.copy()
    artix_mmcm_cascade_blank_test_dict["frequency_args"]["f_out_4_cascade"] = True

    def setup_artix_configurators(self) -> None:
        """
        Sets two configurators, one for plle2base and one for mmcme2base, up for testing, using an artix model
        :return: None
        """
        self.artix_mmcm_base_configurator = ClockingConfigurator(self.artix_model, MmcmBlockConfiguration.get_new_instance())
        self.artix_pll_base_configurator = ClockingConfigurator(self.artix_model, PllBlockConfiguration.get_new_instance())

    def setup_kintex_configurators(self) -> None:
        """
        Sets two configurators, one for plle2base and one for mmcme2base, up for testing, using a kintex model
        :return: None
        """
        self.kintex_mmcm_base_configurator = ClockingConfigurator(self.kintex_model, MmcmBlockConfiguration.get_new_instance())
        self.kintex_pll_base_configurator = ClockingConfigurator(self.kintex_model, PllBlockConfiguration.get_new_instance())

    def test_synthesis_and_simulation_with_artix_model(self) -> None:
        self.setup_artix_configurators()

        test_tuples = [(self.artix_pll_base_configurator, self.pll_test_dict, self.signal_names_pll_test),
                       (self.artix_mmcm_base_configurator, self.mmcm_test_dict, self.signal_names_mmcm_test)]

        # Loop over the test tuples to spare some boiler plate code:
        for test_configurator, test_dict, signal_names in test_tuples:
            test_configurator.configure_primitive(**test_dict)

            # Test synthesis and simulation
            write_synthesis_and_clock_report_tcl_script(self.artix_model_vivado_name,
                                                        self.artix_pin_names,
                                                        signal_names,
                                                        simulated_input_frequency=test_dict["frequency_args"]["f_in_1"])
            write_test_verilog_template(test_configurator.generate_template())
            # Run script
            log = run_generated_tcl_script()
            # Test if synthesis threw no error
            self.assertNotIn("ERROR:", log)

            report_dict = get_value_dict_from_clock_report()
            # Check if simulation logs and expected values are nearly equal (take rounding errors into account)
            for index, dic in test_configurator.get_expected_values_dict().items():
                self.assertAlmostEqual(dic["frequency"], report_dict[f"clkout{index}_OBUF"]["frequency"],
                                       delta=0.75)
                '''
                self.assertAlmostEqual(dic["duty_cycle"], report_dict[f"clkout{index}_OBUF"]["duty_cycle"],
                                       delta=0.15)
                '''
                self.assertAlmostEqual(dic["phase_shift"], report_dict[f"clkout{index}_OBUF"]["phase_shift"],
                                       delta=0.15)

    def test_synthesis_and_simulation_with_kintex_model(self) -> None:
        self.setup_kintex_configurators()

        test_tuples = [(self.kintex_pll_base_configurator, self.pll_kintex_test_dict, self.signal_names_pll_test),
                       (self.kintex_mmcm_base_configurator, self.mmcm_kintex_test_dict, self.signal_names_mmcm_test)]

        # Loop over the test tuples to spare some boiler plate code:
        for test_configurator, test_dict, signal_names in test_tuples:
            test_configurator.configure_primitive(**test_dict)

            # Test synthesis and simulation
            write_synthesis_and_clock_report_tcl_script(self.kintex_model_vivado_name,
                                                        self.kintex_pin_names,
                                                        signal_names,
                                                        simulated_input_frequency=test_dict["frequency_args"]["f_in_1"])
            write_test_verilog_template(test_configurator.generate_template())
            # Run script
            log = run_generated_tcl_script()
            # Test if synthesis threw no error
            self.assertNotIn("ERROR:", log)

            report_dict = get_value_dict_from_clock_report()
            # Check if simulation logs and expected values are nearly equal (take rounding errors into account)
            for index, dic in test_configurator.get_expected_values_dict().items():
                self.assertAlmostEqual(dic["frequency"], report_dict[f"clkout{index}_OBUF"]["frequency"],
                                       delta=0.75)
                '''
                self.assertAlmostEqual(dic["duty_cycle"], report_dict[f"clkout{index}_OBUF"]["duty_cycle"],
                                       delta=0.15)
                '''
                self.assertAlmostEqual(dic["phase_shift"], report_dict[f"clkout{index}_OBUF"]["phase_shift"],
                                       delta=0.15)

    def test_synthesis_and_simulation_with_auto_generated_deltas(self):
        self.setup_artix_configurators()

        test_tuples = [(self.artix_pll_base_configurator, self.pll_test_dict_without_deltas,
                        self.signal_names_pll_test),
                       (self.artix_mmcm_base_configurator, self.mmcm_test_dict_witout_deltas,
                        self.signal_names_mmcm_test)]

        # Loop over the test tuples to spare some boiler plate code:
        for test_configurator, test_dict, signal_names in test_tuples:
            test_configurator.configure_primitive_like_vivado(**test_dict)

            # Test synthesis and simulation
            write_synthesis_and_clock_report_tcl_script(self.artix_model_vivado_name,
                                                        self.artix_pin_names,
                                                        signal_names,
                                                        simulated_input_frequency=test_dict["frequency_args"]["f_in_1"])
            write_test_verilog_template(test_configurator.generate_template())
            # Run script
            log = run_generated_tcl_script()
            # Test if synthesis threw no error
            self.assertNotIn("ERROR:", log)

            report_dict = get_value_dict_from_clock_report()
            # Check if simulation logs and expected values are nearly equal (take rounding errors into account)
            for index, dic in test_configurator.get_expected_values_dict().items():
                self.assertAlmostEqual(dic["frequency"], report_dict[f"clkout{index}_OBUF"]["frequency"],
                                       delta=0.75)
                '''
                self.assertAlmostEqual(dic["duty_cycle"], report_dict[f"clkout{index}_OBUF"]["duty_cycle"],
                                       delta=0.15)
                '''
                self.assertAlmostEqual(dic["phase_shift"], report_dict[f"clkout{index}_OBUF"]["phase_shift"],
                                       delta=0.15)

    def test_synthesis_and_simulation_with_clk4_cascade(self):
        self.setup_artix_configurators()

        test_tuples = [(self.artix_mmcm_base_configurator, dic, self.signal_names_mmcm_test)
                       for dic in [self.artix_mmcm_cascade_blank_test_dict, self.artix_mmcm_cascade_test_dict_1,
                                   self.artix_mmcm_cascade_test_dict_2]]

        # Loop over the test tuples to spare some boiler plate code:
        for test_configurator, test_dict, signal_names in test_tuples:
            test_configurator.configure_primitive_like_vivado(**test_dict)
            print(test_configurator.selected_candidate)

            # Test synthesis and simulation
            write_synthesis_and_clock_report_tcl_script(self.artix_model_vivado_name,
                                                        self.artix_pin_names,
                                                        signal_names,
                                                        simulated_input_frequency=test_dict["frequency_args"]["f_in_1"])
            write_test_verilog_template(test_configurator.generate_template())
            # Run script
            log = run_generated_tcl_script()
            # Test if synthesis threw no error
            self.assertNotIn("ERROR:", log)

            report_dict = get_value_dict_from_clock_report()
            # Check if simulation logs and expected values are nearly equal (take rounding errors into account)
            for index, dic in test_configurator.get_expected_values_dict().items():
                self.assertAlmostEqual(dic["frequency"], report_dict[f"clkout{index}_OBUF"]["frequency"],
                                       delta=0.75)
                '''
                self.assertAlmostEqual(dic["duty_cycle"], report_dict[f"clkout{index}_OBUF"]["duty_cycle"],
                                       delta=0.15)
                '''
                self.assertAlmostEqual(dic["phase_shift"], report_dict[f"clkout{index}_OBUF"]["phase_shift"],
                                       delta=0.15)
