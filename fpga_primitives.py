"""
This modules contains classes that save the current state of a configuration.
"""
from fpga_globals import get_clock_attributes
from utility import frequency_to_period_ns_precision, period_to_frequency_mhz_precision, absolute_error
from fpga_clk_attr import *


@dataclass
class ClockBlockConfiguration(ABC):
    bandwidth: ListAttribute
    ref_jitter1: IncrementRangeAttribute
    startup_wait: BoolAttribute
    clkfbout_phase: IncrementRangeAttribute
    clkin1_period: RangeAttribute
    divclk_divide: IncrementRangeAttribute

    clkout1_divide: OutputDivider
    clkout2_divide: OutputDivider
    clkout3_divide: OutputDivider
    clkout4_divide: OutputDivider
    clkout5_divide: OutputDivider

    clkout0_duty_cycle: IncrementRangeAttribute
    clkout1_duty_cycle: IncrementRangeAttribute
    clkout2_duty_cycle: IncrementRangeAttribute
    clkout3_duty_cycle: IncrementRangeAttribute
    clkout4_duty_cycle: IncrementRangeAttribute
    clkout5_duty_cycle: IncrementRangeAttribute

    clkout0_phase: RangeAttribute
    clkout1_phase: RangeAttribute
    clkout2_phase: RangeAttribute
    clkout3_phase: RangeAttribute
    clkout4_phase: RangeAttribute
    clkout5_phase: RangeAttribute

    def __post_init__(self):
        self.specification = None
        self.m = None
        self.d = None
        self.o_list = None
        self.attributes = None
        self.output_clocks = None
        self.delta_score = None

        # Set specification, m, d, o_list and attributes references
        self.initialize_multiplier_and_divider_references()

    @abstractmethod
    def generate_template(self) -> str:
        return ""

    def get_m_generator(self, start=None, end=None):
        return self.m.get_range_as_generator(start=start, end=end)

    def get_d_generator(self, start=None, end=None):
        return self.divclk_divide.get_range_as_generator(start=start, end=end)

    def get_output_frequency_dict(self) -> dict:
        return {index: self.get_output_frequency(index)
                for index
                in range(self.output_clocks)
                if self.o_list[index].on}

    def get_properties_dict(self) -> dict:
        return {attr.name: attr.value for attr in self.attributes if attr.on}

    def get_output_frequency(self, index: int, o_value=None) -> float:
        """
        :param index: index of the output frequency slot
        :param o_value: Only used if frequency is calculated before setting the value
        """
        if not 0 <= index < self.output_clocks:
            raise ValueError(f"Index out of range, pll does not have f_out with index {index}")
        if o_value is not None:
            return self.m.value * period_to_frequency_mhz_precision(self.clkin1_period.value) / \
                   (self.divclk_divide.value * o_value)
        if self.o_list[index].on:
            return self.m.value * period_to_frequency_mhz_precision(self.clkin1_period.value) / \
                   (self.divclk_divide.value * self.o_list[index].value)

    def get_output_divider(self, index) -> OutputDivider:
        if not 0 <= index < self.output_clocks:
            raise ValueError(f"Index out of range, primitive does not have output divider with index {index}")
        return self.o_list[index]

    def get_duty_cycle(self, index: int) -> IncrementRangeAttribute:
        if not 0 <= index < self.output_clocks:
            raise ValueError(f"Index out of range, primitive does not have duty cycle with index {index}")
        return getattr(self, f"clkout{index}_duty_cycle")

    def get_phase_shift(self, index: int) -> IncrementRangeAttribute:
        if not 0 <= index < self.output_clocks:
            raise ValueError(f"Index out of range, primitive does not have output phase shift with index {index}")
        return getattr(self, f"clkout{index}_phase")

    def get_expected_values_dict(self) -> dict:
        """
        Generates a dictionary that contains expected values for clocks generated by this primitives values
        :return: dictionary containing expected output clock values
        """
        return {index: {"frequency": self.get_output_frequency(index),
                        # This line should change if clkfbout_phase if implemented:
                        "phase_shift": self.get_phase_shift(index).value,
                        "duty_cycle": self.get_duty_cycle(index).value
                        }
                for index, o in enumerate(self.o_list) if o.on}

    def set_in_period_based_on_frequency(self, f_in_1: float, f_in_2: float = None):
        self.clkin1_period.set_value(frequency_to_period_ns_precision(f_in_1))
        self.clkin1_period.on = True

    @abstractmethod
    def initialize_multiplier_and_divider_references(self):
        """
        Specializations of this class have to implement m, d and o's for "configure_approximated_o_dividers"
        Attributes named m, d, (and o's) for all specializations of this class would be sufficient in theory
        But those variable names alone might be misleading.
        Therefore references are set on top of non-common values like:
            MmcmBlockConfiguration.m <- MmcmBlockConfiguration.clkfbout_mult_f
            PllBlockConfiguration.m <- PllBlockConfiguration.clkfbout_mult
        These naming conventions fit the Xilinx documents but a common value in the form of m does also exist.
        """
        pass

    def configure_approximated_o_dividers(self, m, d, f_in_1, desired_output_frequencies: dict, deltas: dict,
                                          fpga_f_out_min: float, fpga_f_out_max: float):
        self.set_in_period_based_on_frequency(f_in_1)
        self.m.value = m
        self.m.on = True
        self.d.value = d
        self.d.on = True

        target_dividers = {index: divider
                           for index, divider
                           in enumerate(self.o_list)
                           if index in desired_output_frequencies}

        # Iterate through all outputs that are demanded
        for index, f_out in desired_output_frequencies.items():
            # Most of the time the divider value cannot be exactly achieved
            # So instead we have to chose between two values, one of them is greater than our desired value
            # and the other one is less.
            # They are called upper and lower bound in this case
            lower_bound, upper_bound = target_dividers[index].get_bounds_based_on_value((f_in_1 * m) / (d * f_out))

            # Get the output frequencies that would be generated by using the lower/upper bound divider
            lower_bound_result = self.get_output_frequency(index, o_value=lower_bound)
            upper_bound_result = self.get_output_frequency(index, o_value=upper_bound)

            # It is possible for the generated frequency to go beyond the technical limitations (fpga_f_out_min/max)
            # But at least one of them will not make the output frequency go beyond those limitations
            if lower_bound_result > fpga_f_out_max:
                # Chose upper_bound if lower_bound makes output frequency go beyond limitations
                target_dividers[index].value = upper_bound
            elif upper_bound_result < fpga_f_out_min:
                # Chose lower_bound if upper_bound makes output frequency go beyond limitations
                target_dividers[index].value = lower_bound
            else:
                # If both the lower and the upper bounds generated frequency is within limitations:
                # chose the one that has a smaller relative error
                if relative_error(f_out, upper_bound_result) > relative_error(f_out, lower_bound_result):
                    target_dividers[index].value = lower_bound
                else:
                    target_dividers[index].value = upper_bound

            # Activate the target divider
            target_dividers[index].on = True

        # All of the output dividers have been computed at this point
        # This loop checks whether or not the generated output frequencies are within the deviation margin
        # given by delta values
        actual_f_outs = self.get_output_frequency_dict()
        for index, f_out in desired_output_frequencies.items():
            if relative_error(f_out, actual_f_outs[index]) > deltas[index]:
                # Return False and therefore make higher level functions reject this configuration
                return False

        return True

    def set_delta_score(self, output_frequencies: dict, phase_shifts: dict, use_relative_error: bool = False) -> None:
        """
        Gives the configuration a score based on the sum of the relative errors
        :param use_relative_error:
        :param use_absolute_error:
        :param output_frequencies: Target output frequencies that are about to be compared with the produced frequencies
        :param phase_shifts: Target phase shifts that are about to be compared with the produced phase shifts
        :return: None
        """

        # Add relative error if demanded
        if use_relative_error:
            # Get the sum of all relative frequency errors of this configuration
            frequency_sum = sum([relative_error(target_value, self.get_output_frequency(index))
                                 for index, target_value in output_frequencies.items()])

            # Get the sum of all relative phase shift error of this configuration
            phase_shift_sum = sum([relative_error(target_value, self.get_phase_shift(index).value)
                                   for index, target_value in phase_shifts.items()])

            # Another sum for the duty cycles could be added here if they were implemented

            # Calculate the score
            # This score assumes that phase shifts are less important than output frequencies,
            # by giving their errors a lower weight
            self.delta_score = frequency_sum * 2 + phase_shift_sum

        else:
            # Get the sum of all relative frequency errors of this configuration
            frequency_sum = sum([absolute_error(target_value, self.get_output_frequency(index))
                                 for index, target_value in output_frequencies.items()])

            # Get the sum of all relative phase shift error of this configuration
            phase_shift_sum = sum([absolute_error(target_value, self.get_phase_shift(index).value)
                                   for index, target_value in phase_shifts.items()])

            # Another sum for the duty cycles could be added here if they were implemented

            # Calculate the score
            # This score assumes that phase shifts are less important than output frequencies,
            # by giving their errors a lower weight
            self.delta_score = frequency_sum * 2 + phase_shift_sum

    def get_result_presentation(self, clock_six_used: bool = True) -> str:
        """
        :param clock_six_used: placeholder parameter for mmcm child class
        :return: A string that shows the frequencies, phase shifts etc. that will be synthesized by this configuration
        """

        frequency_ps_string = "\n".join([
            f"clkout{i} frequency: {self.get_output_frequency(i)}\n" \
            f"clkout{i} phase shift: {self.get_phase_shift(i).value}\n"
            for i, output_divider in enumerate(self.o_list)
            if output_divider.on and (i != 6 or i == 6 and clock_six_used)
        ])

        other_str = "\n"
        other_str += f"reference jitter1: {self.ref_jitter1.value}\n" if self.ref_jitter1.on else ""
        other_str += f"bandwidth: {self.bandwidth.value}\n"
        other_str += f"startup wait: {self.startup_wait.value}\n"

        return frequency_ps_string + other_str

    @classmethod
    @abstractmethod
    def get_new_instance(cls):
        pass


@dataclass
class PllBlockConfiguration(ClockBlockConfiguration):
    clkfbout_mult: IncrementRangeAttribute
    clkout0_divide: OutputDivider

    output_clocks = 6

    def __str__(self) -> str:
        attr_strings = [attr.instantiate_template() for attr in self.attributes
                        if attr.on and attr.value != attr.default_value]

        return "\tPLLE2_BASE #(\n\t\t" + ",\n\t\t".join(attr_strings) + "\n\t)\n"

    def generate_template(self) -> str:
        return "`timescale 1ps/1ps" \
               "\nmodule clk" \
               "\n\t(" \
               "\n\t\tinput\tclkin1," \
               "\n\t\tinput\tpwrdwn," \
               "\n\t\tinput\trst," \
               "\n\t\tinput\tclkfbin," \
               "\n\t\toutput\tclkout0," \
               "\n\t\toutput\tclkout1," \
               "\n\t\toutput\tclkout2," \
               "\n\t\toutput\tclkout3," \
               "\n\t\toutput\tclkout4," \
               "\n\t\toutput\tclkout5," \
               "\n\t\toutput\tclkfbout," \
               "\n\t\toutput\tlocked" \
               "\n\t);" \
               "\n\n\t//Here could be your code for wires and input buffers" \
               f"\n\n{self.__str__()}" \
               "\tPLLE2_BASE_inst(" \
               "\n\t\t.CLKOUT0(clkout0)," \
               "\n\t\t.CLKOUT1(clkout1)," \
               "\n\t\t.CLKOUT2(clkout2)," \
               "\n\t\t.CLKOUT3(clkout3)," \
               "\n\t\t.CLKOUT4(clkout4)," \
               "\n\t\t.CLKOUT5(clkout5)," \
               "\n\t\t.CLKFBOUT(clkfbout)," \
               "\n\t\t.LOCKED(locked)," \
               "\n\t\t.CLKIN1(clkin1)," \
               "\n\t\t.PWRDWN(pwrdwn)," \
               "\n\t\t.RST(rst)," \
               "\n\t\t.CLKFBIN(clkfbin)" \
               "\n\t);" \
               "\n\n\t//Here could be your code for wires and output buffers" \
               "\n\nendmodule"

    def initialize_multiplier_and_divider_references(self):
        self.specification = "pll"
        self.m = self.clkfbout_mult
        self.d = self.divclk_divide
        self.o_list = [self.clkout0_divide, self.clkout1_divide, self.clkout2_divide, self.clkout3_divide,
                       self.clkout4_divide, self.clkout5_divide]
        self.attributes = [self.bandwidth, self.clkfbout_mult, self.clkfbout_phase, self.clkin1_period,
                           self.divclk_divide, self.ref_jitter1, self.startup_wait, self.clkout0_divide,
                           self.clkout1_divide, self.clkout2_divide, self.clkout3_divide, self.clkout4_divide,
                           self.clkout5_divide, self.clkout0_duty_cycle, self.clkout1_duty_cycle,
                           self.clkout2_duty_cycle, self.clkout3_duty_cycle, self.clkout4_duty_cycle,
                           self.clkout5_duty_cycle, self.clkout0_phase, self.clkout1_phase, self.clkout2_phase,
                           self.clkout3_phase, self.clkout4_phase, self.clkout5_phase]
        self.output_clocks = 6

    @classmethod
    def get_new_instance(cls):
        return cls(**get_clock_attributes("PllBlockConfiguration"))


@dataclass
class MmcmBlockConfiguration(ClockBlockConfiguration):
    clkfbout_mult_f: IncrementRangeAttribute
    clkout4_cascade: BoolAttribute
    clkout0_divide_f: OutputDivider

    clkout6_divide: OutputDivider
    clkout6_duty_cycle: IncrementRangeAttribute
    clkout6_phase: RangeAttribute

    output_clocks = 7

    def __str__(self):
        attr_strings = [attr.instantiate_template() for attr in self.attributes
                        if attr.on and attr.value != attr.default_value]
        return "\tMMCME2_BASE #(\n\t\t" + ",\n\t\t".join(attr_strings) + "\n\t)\n"

    def generate_template(self) -> str:
        return "`timescale 1ps/1ps" \
               "\nmodule clk" \
               "\n\t(" \
               "\n\t\tinput\tclkin1," \
               "\n\t\tinput\tpwrdwn," \
               "\n\t\tinput\trst," \
               "\n\t\tinput\tclkfbin," \
               "\n\t\toutput\tclkout0," \
               "\n\t\toutput\tclkout0b," \
               "\n\t\toutput\tclkout1," \
               "\n\t\toutput\tclkout1b," \
               "\n\t\toutput\tclkout2," \
               "\n\t\toutput\tclkout2b," \
               "\n\t\toutput\tclkout3," \
               "\n\t\toutput\tclkout3b," \
               "\n\t\toutput\tclkout4," \
               "\n\t\toutput\tclkout5," \
               "\n\t\toutput\tclkout6," \
               "\n\t\toutput\tclkfbout," \
               "\n\t\toutput\tclkboutb," \
               "\n\t\toutput\tlocked" \
               "\n\t);" \
               "\n\n\t//Here could be your code for wires and input buffers" \
               f"\n\n{self.__str__()}" \
               "\tMMCME2_BASE_inst(" \
               "\n\t\t.CLKOUT0(clkout0)," \
               "\n\t\t.CLKOUT0B(clkout0b)," \
               "\n\t\t.CLKOUT1(clkout1)," \
               "\n\t\t.CLKOUT1B(clkout1b)," \
               "\n\t\t.CLKOUT2(clkout2)," \
               "\n\t\t.CLKOUT2B(clkout2b)," \
               "\n\t\t.CLKOUT3(clkout3)," \
               "\n\t\t.CLKOUT3B(clkout3b)," \
               "\n\t\t.CLKOUT4(clkout4)," \
               "\n\t\t.CLKOUT5(clkout5)," \
               "\n\t\t.CLKOUT6(clkout6)," \
               "\n\t\t.CLKFBOUT(clkfbout)," \
               "\n\t\t.CLKFBOUTB(clkboutb)," \
               "\n\t\t.LOCKED(locked)," \
               "\n\t\t.CLKIN1(clkin1)," \
               "\n\t\t.PWRDWN(pwrdwn)," \
               "\n\t\t.RST(rst)," \
               "\n\t\t.CLKFBIN(clkfbin)" \
               "\n\t);" \
               "\n\n\t//Here could be your code for wires and output buffers" \
               "\n\nendmodule"

    def get_output_frequency(self, index: int, o_value=None) -> float:
        """
        :param index: index of the output frequency slot
        :param o_value: Only used if frequency is calculated before setting the value
        """
        temp_o = o_value if o_value is not None else self.o_list[index].value
        if not 0 <= index < self.output_clocks:
            raise ValueError(f"Index out of range, pll does not have f_out with index {index}")
        # TODO make this more beatiful
        if index == 4 and self.clkout4_cascade.on:
            return self.m.value * period_to_frequency_mhz_precision(self.clkin1_period.value) / \
                   (self.divclk_divide.value * temp_o * self.o_list[6].value)
        else:
            return self.m.value * period_to_frequency_mhz_precision(self.clkin1_period.value) / \
                   (self.divclk_divide.value * temp_o)

    def initialize_multiplier_and_divider_references(self):
        self.specification = "mmcm"
        self.m = self.clkfbout_mult_f
        self.d = self.divclk_divide
        self.o_list = [self.clkout0_divide_f, self.clkout1_divide, self.clkout2_divide, self.clkout3_divide,
                       self.clkout4_divide, self.clkout5_divide, self.clkout6_divide]
        self.attributes = [self.bandwidth, self.ref_jitter1, self.startup_wait, self.clkfbout_mult_f,
                           self.clkfbout_phase, self.clkin1_period, self.divclk_divide, self.clkout4_cascade,
                           self.clkout0_divide_f, self.clkout1_divide, self.clkout2_divide, self.clkout3_divide,
                           self.clkout4_divide, self.clkout5_divide, self.clkout6_divide, self.clkout0_duty_cycle,
                           self.clkout1_duty_cycle, self.clkout2_duty_cycle, self.clkout3_duty_cycle,
                           self.clkout4_duty_cycle, self.clkout5_duty_cycle, self.clkout6_duty_cycle,
                           self.clkout0_phase, self.clkout1_phase, self.clkout2_phase, self.clkout3_phase,
                           self.clkout4_phase, self.clkout5_phase, self.clkout6_phase]
        self.output_clocks = 7

    def approximate_o_divider(self, index, m, d, f_in_1, target_f_out: float, delta: float, fpga_f_out_min: float,
                              fpga_f_out_max: float):
        self.set_in_period_based_on_frequency(f_in_1)
        self.m.value = m
        self.d.value = d

        target_divider = self.o_list[index]

        # Get the lower and upper bound (for more information look up "configure_approximated_o_dividers")
        lower_bound, upper_bound = target_divider.get_bounds_based_on_value((f_in_1 * m) / (d * target_f_out))

        lower_bound_result = (m * f_in_1) / (lower_bound * d)
        upper_bound_result = (m * f_in_1) / (upper_bound * d)

        # It is possible for the generated frequency to go beyond the technical limitations (fpga_f_out_min/max)
        # But at least one of them will not make the output frequency go beyond those limitations
        if lower_bound_result > fpga_f_out_max:
            # Chose upper_bound if lower_bound makes output frequency go beyond limitations
            target_divider.value = upper_bound
        elif upper_bound_result < fpga_f_out_min:
            # Chose lower_bound if upper_bound makes output frequency go beyond limitations
            target_divider.value = lower_bound
        else:
            # If both the lower and the upper bounds generated frequency is within limitations:
            # chose the one that has a smaller relative error
            if relative_error(target_f_out, upper_bound_result) > relative_error(target_f_out, lower_bound_result):
                target_divider.value = lower_bound
            else:
                target_divider.value = upper_bound

        # Activate the target divider
        target_divider.on = True

        # All of the output dividers have been computed at this point
        # This loop checks whether or not the generated output frequencies are within the deviation margin
        # given by delta values
        actual_f_out = self.get_output_frequency(index)
        if relative_error(actual_f_out, target_f_out) > delta:
            # Return False and therefore make higher level functions reject this configuration
            return None

        return target_divider.value

    def get_result_presentation(self, clock_six_used: bool = True) -> str:
        string_with_clk4cascade = super().get_result_presentation(clock_six_used) + \
                                  f"clock 4 cascade: {self.clkout4_cascade.value}\n"

        return string_with_clk4cascade

    @classmethod
    def get_new_instance(cls):
        return cls(**get_clock_attributes("MmcmBlockConfiguration"))
